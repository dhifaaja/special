<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Candle Blow</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { background-color: #333; }
    .controls { position: fixed; top: 10px; right: 10px; display: flex; gap: 5px; }
    .share-link { font-size: 14px; padding: 4px 6px; border-radius: 6px; background: #f0f0f0; cursor: pointer; }
    .candle-count-display { text-align: center; margin-top: 50px; margin-bottom: 20px; font-family: Arial, sans-serif; font-size: 20px; color: #6A4B18; background-color: #F0E4D0; padding: 10px; border-radius: 10px; width: fit-content; margin-left: auto; margin-right: auto; border: 2px solid #553C13; }
    .candle-count-display span { font-weight: bold; color: #AD030F; }
    /* Masukkan semua CSS cake, layer, icing, candle, flame, dll di sini */
  </style>
</head>
<body>

<div class="instructions">
  Click on the cake to add candles, then share the link!
</div>

<div class="controls">
  <button class="share-link" onclick="copyShareLink()">🕯️</button>
  <button class="share-link" onclick="clearCandles()">🎈</button>
</div>

<div class="candle-count-display">
  Candles on the Cake: <span id="candleCount">0</span>
</div>

<div class="cake">
  <div class="plate"></div>
  <div class="layer layer-bottom"></div>
  <div class="layer layer-middle"></div>
  <div class="layer layer-top"></div>
  <div class="icing"></div>
  <div class="drip drip1"></div>
  <div class="drip drip2"></div>
  <div class="drip drip3"></div>
<div class="cake-text">祝你生日快乐</div>
</div>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const cake = document.querySelector(".cake");
    const candleCountDisplay = document.getElementById("candleCount");
    let candles = [];
    let audioContext, analyser, microphone;

    function updateCandleCount() {
      const activeCandles = candles.filter(c => !c.classList.contains("out")).length;
      candleCountDisplay.textContent = activeCandles;
    }

    function addCandle(left, top, isOut = false) {
      const candle = document.createElement("div");
      candle.className = "candle";
      if (isOut) candle.classList.add("out");
      candle.style.left = left + "px";
      candle.style.top = top + "px";

      const flame = document.createElement("div");
      flame.className = "flame";
      candle.appendChild(flame);

      cake.appendChild(candle);
      candles.push(candle);
      updateCandleCount();
      updateURL();
    }

    function saveCandlesToURL() {
      const candleData = candles.map(c => ({
        left: parseInt(c.style.left),
        top: parseInt(c.style.top),
        out: c.classList.contains("out")
      }));
      const encoded = btoa(JSON.stringify(candleData));
      const url = new URL(window.location);
      url.searchParams.set('candles', encoded);
      window.history.replaceState({}, '', url);
    }

    function loadCandlesFromURL() {
      const params = new URLSearchParams(window.location.search);
      const candleData = params.get('candles');
      if (candleData) {
        try {
          const decoded = JSON.parse(atob(candleData));
          decoded.forEach(c => addCandle(c.left, c.top, c.out));
        } catch(e) { console.log(e); }
      }
    }

    function updateURL() { saveCandlesToURL(); }

    window.copyShareLink = function() {
      saveCandlesToURL();
      navigator.clipboard.writeText(window.location.href).then(() => alert('Link copied!'));
    }

    window.clearCandles = function() {
      candles.forEach(c => c.remove());
      candles = [];
      updateCandleCount();
      const url = new URL(window.location);
      url.searchParams.delete('candles');
      window.history.replaceState({}, '', url);
    }

    cake.addEventListener("click", function (e) {
      const rect = cake.getBoundingClientRect();
      addCandle(e.clientX - rect.left, e.clientY - rect.top);
    });

    // Optional: microphone blow detection
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        microphone = audioContext.createMediaStreamSource(stream);
        microphone.connect(analyser);
        analyser.fftSize = 256;
        setInterval(() => {
          const bufferLength = analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);
          analyser.getByteFrequencyData(dataArray);
          const average = dataArray.reduce((a,b) => a+b)/bufferLength;
          if (average > 40) {
            candles.forEach(c => { if (!c.classList.contains("out") && Math.random()>0.5) c.classList.add("out"); });
            updateCandleCount();
            updateURL();
          }
        }, 200);
      }).catch(err => console.log(err));
    }

    loadCandlesFromURL();
  });
</script>

</body>
</html>
